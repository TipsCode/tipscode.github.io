{"instances":{"application":{"persistent":false},"FacebookPixel/0-0-0-0-0":{"persistent":false},"GoogleAnalytics/0-0-0-0-1":{"persistent":false},"Article_Articles/0-0-12/event-loop-em-node-guia-completo":{"persistent":false,"slug":"event-loop-em-node-guia-completo","content":"<p>A assincronia em qualquer linguagem de programação é difícil e o <strong>event loop</strong> vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware.</p>\n<p>JavaScript é de thread única, mas isso limita o Node de utilizar arquitetura moderna? Um dos maiores desafios é lidar com várias threads por causa de sua complexidade inerente. Criar novas threads e gerenciar a troca de contexto entre elas é caro. Tanto o sistema operacional quanto o programador devem trabalhar muito para fornecer uma solução. Neste artigo, mostrarei como o Node lida com <strong>event loop</strong>. Explorarei cada parte do event loop do Node.js e demonstrarei como ele funciona. Um dos recursos melhores recursos do Node é o event loop, porque ele resolveu um problema difícil de uma maneira inovadora</p>\n<h2>Event Loop</h2>\n<p>O <strong>event loop</strong> é um loop simultâneo de thread única, sem bloqueio e de forma assíncrona. Imagine uma solicitação web que faz uma pesquisa no banco de dados. Uma única <strong>thread</strong> só pode fazer uma coisa de cada vez. Em vez de aguardar a resposta do banco de dados, ele continua a selecionar outras tarefas na fila. No <strong>event loop</strong>, o loop principal desenrola a pilha de chamadas e não espera os retornos de chamada. Como o loop não bloqueia, é tranquilo fazer mais de uma solicitação web por vez. Várias solicitações podem ser enfileiradas ao mesmo tempo, o que as torna simultâneas. O event loop não espera que uma solicitação seja concluído, mas pega retornos de chamada conforme eles vêm, sem bloqueio.</p>\n<p>O <strong>event loop</strong> em si é semi-infinito, o que significa que se a pilha de chamadas ou a fila de retorno de chamada estiverem vazias, ele pode sair do loop. Pense na pilha de chamadas como um código síncrono que se desenrola, como console.log, antes que o loop busque mais trabalho. O Node usa <strong>libuv</strong> por baixo dos panos para pesquisar no sistema operacional em busca de retornos de chamada de conexões de entrada.</p>\n<p>Você pode estar se perguntando, por que o event loop é executado em uma única thread? <strong>Threads</strong> são relativamente pesados ​​na memória para os dados de que necessita por conexão. Threads são recursos do sistema operacional que aumentam e isso não é escalonável para milhares de conexões ativas.</p>\n<p>Vários tópicos em geral também complicam a história. Se um retorno de chamada retornar com dados, ele deve empacotar o contexto de volta para a thread que está em execução. A troca de contexto entre threads é lenta, porque deve sincronizar o estado atual, como a pilha de chamadas ou variáveis ​​locais. O event loop elimina os bugs quando várias threads compartilham recursos, porque é thread única. Um loop de thread única corta casos extremos de segurança de thread e pode mudar de contexto muito mais rápido. Este é o verdadeiro lance por trás do event loop. Ele faz uso efetivo de conexões e threads enquanto permanece escalável.</p>\n<h2>Loop Semi-infinito</h2>\n<p>A maior pergunta que o event loop deve responder é se o loop está ativo. Em caso afirmativo, ele descobre quanto tempo deve esperar na fila de retorno de chamada. A cada iteração, o loop desenrola a pilha de chamadas e, em seguida, pesquisa.</p>\n<p>Aqui está um exemplo que bloqueia o loop principal:</p>\n<pre><code><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Oi a fila de retorno'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Mantenha o loop ativo por x tempo</span>\n\n<span class=\"token keyword\">const</span> stopTime <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> stopTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// Bloqueie o loop principal</span>\n</code></pre>\n<p>Se você executar este código, observe que o loop fica bloqueado por dois segundos. Mas o loop permanece ativo até que o retorno de chamada seja executado em cinco segundos. Depois que o loop principal é desbloqueado, o mecanismo de pesquisa descobre quanto tempo ele espera nos retornos de chamada. Esse loop termina quando a pilha de chamadas é desfeita e não há mais retornos de chamada restantes.</p>\n<h2>A fila de retorno de chamada</h2>\n<p>Agora, o que acontece quando eu bloqueio o loop principal e agendo um retorno de chamada? Uma vez que o loop é bloqueado, ele não coloca mais callbacks na fila:</p>\n<pre><code><span class=\"token keyword\">const</span> stopTime <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> stopTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// Bloqueie o loop principal</span>\n\n<span class=\"token comment\">// Isso leva 7 segundos para ser executado</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Executou callback A'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Desta vez, o loop permanece ativo por sete segundos. O event loop é burro em sua simplicidade. Ele não tem como saber o que pode ser colocado na fila no futuro. Em um sistema real, os retornos de chamada de entrada são enfileirados e executados, pois o loop principal está livre para pesquisar. O event loop passa por várias fases <em>sequencialmente</em> quando é desbloqueado. Portanto, para vencer aquela entrevista de emprego sobre o loop, evite jargões sofisticados como “emissor de evento” ou “padrão de reator”. É um humilde loop de thread único, simultâneo e não bloqueador, não precisa querer complica, lembre-se o simples é poderoso.</p>\n<h2>O Event Loop assíncrono / espera</h2>\n<p>Para evitar o bloqueio do loop principal, uma ideia é envolver a E / S síncrona em torno do recurso async / await. Caso esteja procurando um bom curso / treinamento de NodeJS te <a href=\"/programador-fullstack-8-semanas\">recomendo esse aqui</a>.</p>\n<pre><code><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">readFileSync</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">path</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">await</span> fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">readFileSync</span><span class=\"token punctuation\">(</span><span class=\"token string\">'readme.md'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'O event loop continua sem bloqueio...'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Tudo o que vier depois de <strong>await</strong> vem da fila de retorno de chamada. O código é lido como um código de bloqueio síncrono, mas não bloqueia. Note que async / <a href=\"https://youtu.be/IR9azXeWs2s\" target=\"_blank\" rel=\"noopener\">readFileSync</a> await o torna possível, o que o tira do loop principal. Pense em tudo o que vem depois await como não-bloqueador por meio de um retorno de chamada.</p>\n<p>O código acima é apenas para fins de demonstração. Em código real, eu recomendo <a href=\"https://youtu.be/IR9azXeWs2s\" target=\"_blank\" rel=\"noopener\">fs.readFile</a>, que dispara um retorno de chamada que pode envolver uma <a href=\"https://youtu.be/fRa33RSJpSo\" target=\"_blank\" rel=\"noopener\">promise</a>. A intenção geral ainda é válida, porque isso tira o bloqueio de E / S do loop principal.</p>\n<h2>Mais detalhes sobre</h2>\n<p>E se eu dissesse que o <strong>event loop</strong> tem mais do que uma pilha de chamada e mais uma fila de retorno de chamada? E se o <strong>event loop</strong> não fosse apenas um loop, mas muitos?</p>\n<p>Agora, quero levá-lo para trás da fachada e para visualiza com mais detalhes os componentes internos do <a href=\"/conhecendo-nodejs/\">NodeJS</a></p>\n<h2>Fases do Event Loop</h2>\n<p>Estas são as fases do <strong>Event Loop</strong>:</p>\n<p><img src=\"/uploads/2020/09/event-loop.png\" alt=\"event loop\n\"></p>\n<p>Estrutura event loop</p>\n<p>1 . Ás datas / hora são atualizadas. O <strong>Event loop</strong> armazena em cache a hora atual no início do loop para evitar chamadas de sistema frequentes relacionadas ao tempo. Essas chamadas de sistema são internas à <strong>libuv</strong>.</p>\n<p>2 . O loop está vivo? Se o loop tiver identificadores ativos, solicitações ativas ou identificadores de fechamento, ele está vivo. Conforme mostrado, retornos de chamada pendentes na fila mantêm o loop ativo.</p>\n<p>3 . Os cronômetros de vencimento são executados. Este é o lugar onde o <strong>setTimeout</strong>() ou <strong>setInterval</strong>() retornos de chamada executada. O loop verifica o cache se tem <strong>callbacks</strong> ativos que expiraram em execução.</p>\n<p>4 . Retornos de chamada pendentes na fila são executados. Se a iteração anterior adiou quaisquer retornos de chamada, eles serão executados neste ponto. O <strong>polling</strong> normalmente executa <strong>callbacks</strong> de E / S imediatamente, mas há exceções. Esta etapa lida com quaisquer retardatários da iteração anterior.</p>\n<p>5 . Manipuladores ociosos são executados - principalmente a partir de nomenclatura inadequada, porque eles são executados a cada iteração e são internos ao libuv.</p>\n<p>6 . Prepare identificadores para <strong>setImmediate()</strong> execução de retorno de chamada na iteração do loop. Esses identificadores são executados antes dos blocos do loop para E / S e preparam a fila para esse tipo de retorno de chamada.</p>\n<p>7 . Calcule o tempo limite da votação. O loop deve saber quanto tempo ele bloqueia para E / S. É assim que ele calcula o tempo limite:</p>\n<ul>\n<li>Se o loop estiver prestes a sair, o tempo limite é 0;</li>\n<li>Se não houver identificadores ou solicitações ativas, o tempo limite será 0;</li>\n<li>Se houver algum identificador inativo, o tempo limite é 0;</li>\n<li>Se houver algum identificador pendente na fila, o tempo limite será 0;</li>\n<li>Se houver alguma fechamento, o tempo limite é 0;</li>\n<li>Se nenhuma das opções acima, o tempo limite é definido para o temporizador mais próximo ou, se não houver temporizadores ativos, infinito.</li>\n</ul>\n<p>8 . O loop bloqueia para E / S com a duração da fase anterior. Os retornos de chamada relacionados a E / S na fila são executados neste ponto.</p>\n<p>9 . Verifique a execução de callbacks do identificador. Esta fase é onde <strong>setImmediate()</strong> funciona e é a contrapartida para preparar. Quaisquer <strong>setImmediate()</strong> retornos de chamada enfileirados no meio da execução de retorno de chamada de E / S são executados aqui.</p>\n<p>10 . Fechar callbacks são executados. Esses são identificadores ativos descartados de conexões fechadas.</p>\n<p>11 . A iteração termina.</p>\n<p>Você deve estar se perguntando por que a pesquisa bloqueia E / S quando deveria ser sem bloqueio? O loop bloqueia apenas quando não há retornos de chamada pendentes na fila e a pilha de chamadas está vazia. No Node, o temporizador mais próximo pode ser definido por <strong>setTimeout</strong>, por exemplo. Se definido como infinito, o loop espera nas conexões de entrada com mais trabalho. É um loop semi-infinito, porque a pesquisa mantém o loop ativo quando não há mais nada a fazer e há uma conexão ativa.</p>\n<p>Aqui está a versão Unix deste cálculo de tempo limite é toda a sua glória C:</p>\n<pre><code>int <span class=\"token function\">uv_backend_timeout</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token keyword\">const</span> uv_loop_t<span class=\"token operator\">*</span> loop</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loop<span class=\"token operator\">-</span><span class=\"token operator\">></span>stop_flag <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">uv__has_active_handles</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">uv__has_active_reqs</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token constant\">QUEUE_EMPTY</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>loop<span class=\"token operator\">-</span><span class=\"token operator\">></span>idle_handles<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token constant\">QUEUE_EMPTY</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>loop<span class=\"token operator\">-</span><span class=\"token operator\">></span>pending_queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loop<span class=\"token operator\">-</span><span class=\"token operator\">></span>closing_handles<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">uv__next_timeout</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>Você pode não estar muito familiarizado com C, mas parece inglês e faz exatamente o que está na fase sete.</p>\n<h2>Uma demonstração fase a fase</h2>\n<p>Para mostrar cada fase em JavaScript simples:</p>\n<pre><code><span class=\"token comment\">// 1. Loop começa, o timestamps é atualizados</span>\n<span class=\"token keyword\">const</span> http <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 2. O loop permanece vivo se houver código na pilha de chamadas para desenrolar</span>\n<span class=\"token comment\">// 8. Pesquisar E / S e executar este retorno de chamada de conexões de entrada</span>\n<span class=\"token keyword\">const</span> server <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// O retorno de chamada de E / S da rede é executado imediatamente após a pesquisa</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Mantenha o loop ativo se houver uma conexão aberta</span>\n<span class=\"token comment\">// 7. Se não houver mais nada a fazer, calcule o tempo limite</span>\nserver<span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> options <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Evite uma consulta DNS para ficar fora do pool de threads</span>\n  <span class=\"token literal-property property\">hostname</span><span class=\"token operator\">:</span> <span class=\"token string\">'192.0.2.1'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">port</span><span class=\"token operator\">:</span> <span class=\"token number\">3000</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">sendHttpRequest</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Callbacks de E / S de rede executados na fase 8</span>\n  <span class=\"token comment\">// Callbacks de E / S de arquivo executados na fase 4</span>\n  <span class=\"token keyword\">const</span> req <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>options<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Resposta recebida do servidor'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// 9. Executar verificação de retorno de chamada</span>\n    <span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n      <span class=\"token comment\">// 10. Feche a execução da callback</span>\n       server<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n        <span class=\"token comment\">// O fim. ALERTA DE SPOILER! O Loop morre no final.</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Fechando servidor'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  req<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 3. O cronômetro é executado em 8 segundos, enquanto o loop permanece ativo</span>\n<span class=\"token comment\">// O tempo limite calculado antes da votação o mantém ativo</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">sendHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 11. Fim da iteração..</span>\n</code></pre>\n<p>Como os callbacks de E / S de arquivo são executados na fase quatro e antes da fase nove, espere <strong>setImmediate()</strong> disparar primeiro:</p>\n<pre><code>fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'leiame.md'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Arquivo I/O callback via setTimeout()'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// Este retorno de chamada é executado primeiro</span>\n  <span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Arquivo I/O callback via setImmediate()'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>A E / S de rede sem uma pesquisa de DNS é menos cara do que a E / S de arquivo, porque é executada no <strong>event loop</strong> principal. Em vez disso, a E / S do arquivo é enfileirada por meio do pool de threads. Uma pesquisa de DNS também usa o pool de threads, então isso torna a E / S de rede tão cara quanto a E / S de arquivo.</p>\n<h2>Pool de Thread - Event loop</h2>\n<p>Os componentes internos do nó têm duas partes principais: o mecanismo JavaScript V8 e o libuv. E / S de arquivo, pesquisa de DNS e E / S de rede acontecem via libuv.</p>\n<p>Esta é a arquitetura geral:</p>\n<p><img src=\"/uploads/2020/09/libuv.png\" alt=\"\"></p>\n<p>Fonte da imagem: documentação do <a href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"noopener\">libuv</a></p>\n<p>Para E / S de rede, o <strong>event loop</strong> pesquisa dentro do encadeamento principal. A thread não é segura para threads porque não muda de contexto com outro thread. A E / S de arquivo e a pesquisa de DNS são específicas da plataforma, portanto, a abordagem é executá-los em um pool de threads. Uma ideia é fazer a pesquisa de DNS você mesmo para ficar fora do pool de threads, conforme mostrado no código acima. Colocar um endereço IP versus localhost, por exemplo, tira a pesquisa do pool. O pool de threads tem um número limitado de threads disponíveis, que pode ser definido por UV_THREADPOOL_SIZEmeio da variável de ambiente. O tamanho do pool de threads padrão é cerca de quatro.</p>\n<p>O V8 é executado em um loop separado, esvazia a pilha de chamadas e devolve o controle ao event loop. O V8 pode usar vários encadeamentos para coleta de lixo fora de seu próprio loop. Pense no V8 como o mecanismo que recebe JavaScript bruto e o executa no hardware.</p>\n<p>Para o programador médio, o JavaScript permanece com thread único porque não há segurança de thread. V8 e libuv internos giram seus próprios threads separados para atender às suas próprias necessidades.</p>\n<p>Se houver problemas de taxa de transferência no Node, comece com o event loop principal. Verifique quanto tempo leva para a aplicação concluir uma única iteração. Não deve durar mais do que cem milissegundos. Em seguida, verifique se há inanição do pool de encadeamentos e o que pode ser despejado do pool. Também é possível aumentar o tamanho do pool por meio da variável de ambiente. A última etapa é fazer um microbenchmark do código JavaScript no V8 que é executado de forma síncrona.</p>\n<h2>Empacotando</h2>\n<p>O event loop continua a iterar em cada fase à medida que os retornos de chamada são enfileirados. Mas, dentro de cada fase, há uma maneira de enfileirar outro tipo de retorno de chamada.</p>\n<p><strong>process.nextTick()</strong> vs <strong>setImmediate()</strong></p>\n<p>No final de cada fase, o loop executa o <strong>process.nextTick()</strong> retorno de chamada. Observe que esse tipo de retorno de chamada não faz parte do event loop porque é executado no final de cada fase. O <a href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"noopener\">setImmediate()</a> retorno de chamada faz parte do loop geral de eventos, portanto, não é tão imediato quanto o nome indica. Como <strong>process.nextTick()</strong> precisa de conhecimento avançado de event loop <a href=\"/programador-fullstack-8-semanas\">clique aqui caso queira ir para o próximo nível em nodejs</a>, recomendo o uso <strong>setImmediate()</strong> em geral.</p>\n<p>Existem alguns motivos pelos quais você pode precisar <strong>process.nextTick():</strong></p>\n<ul>\n<li>Permita que a E / S da rede lide com erros, limpe ou tente a solicitação novamente antes que o loop continue;</li>\n<li>Pode ser necessário executar um retorno de chamada após o desenrolar da pilha de chamadas, mas antes que o loop continue.</li>\n</ul>\n<p>Digamos, por exemplo, que um emissor de evento deseja disparar um evento enquanto ainda está em seu próprio construtor. A pilha de chamadas deve ser desenrolada antes de chamar o evento.</p>\n<pre><code><span class=\"token keyword\">const</span> EventEmitter <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'eventos'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ImpatientEmitter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">EventEmitter</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// Acione isso no final da fase com uma pilha de chamadas desfeita</span>\n    process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'eventos'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> emitter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ImpatientEmitter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nemitter<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'event'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Ocorreu um evento impaciente!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>Permitir que a pilha de chamadas seja desenrolada pode evitar erros como RangeError: Maximum call stack size exceeded. Uma pegadinha é ter certeza de process.nextTick()que não bloqueia o event loop O bloqueio pode ser problemático com chamadas de retorno de chamada recursivas na mesma fase.</p>\n<h2>Conclusão</h2>\n<p>O event loop é a simplicidade em sua sofisticação final. É preciso um problema difícil, como assincronia, segurança de thread e simultaneidade. Ele remove o que não ajuda ou o que não precisa e maximiza o rendimento da maneira mais eficaz possível. Por causa disso, os programadores de Node gastam menos tempo com bugs assíncronos e mais tempo entregando novos recursos.</p>\n<h2>Recomendado</h2>\n","date":"2020-09-09T00:00:00.000Z","readingTime":17,"title":"Event Loop NodeJS: Um Guia Completo Para Iniciante","categories":["nodejs"],"tags":["event-loop","javascript","nodejs"],"description":"A assincronia em qualquer linguagem de programação é difícil e o event loop vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware.","imgArticle":"/thumbnail-article/event-loop-nodejs.png","imgHome":"/thumbnail-home/event-loop-nodejs.png"},"Navigation/0-0-12-0-0":{"expanded":false,"persistent":false},"Icon1/0-0-12-0-0-0-0-0-0-1-0":{"persistent":false}},"page":{"image":"/thumbnail-article/event-loop-nodejs.png","status":200,"locale":"pt-BR","title":"Event Loop NodeJS: Um Guia Completo Para Iniciante - TipsCode","description":"A assincronia em qualquer linguagem de programação é difícil e o event loop vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware."}}