<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="Created with Nullstack - https://nullstack.app" />
    <title>Event Loop NodeJS: Um Guia Completo Para Iniciante - TipsCode</title>
    <meta property="og:image" content="https://tipscode.com.br/thumbnail-article/event-loop-nodejs.png">
    <meta property="og:description" content="A assincronia em qualquer linguagem de programação é difícil e o event loop vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware.">
    <meta name="description" content="A assincronia em qualquer linguagem de programação é difícil e o event loop vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware.">
    <meta property="og:title" content="Event Loop NodeJS: Um Guia Completo Para Iniciante - TipsCode">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="TipsCode">
    <meta property="og:url" content="https://tipscode.com.br/event-loop-em-node-guia-completo">
    <link rel="canonical" href="https://tipscode.com.br/event-loop-em-node-guia-completo">
    <meta property="og:locale" content="pt-BR">
    <link rel="shortcut icon" href="/favicon-96x96.png" type="image/png">
    <link rel="icon" href="/favicon-96x96.png" type="image/png">
    <link rel="manifest" href="/manifest.json" integrity="">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="application-name" content="TipsCode">
    <meta name="apple-mobile-web-app-title" content="TipsCode">
    
    <meta name="msapplication-starturl" content="/">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="/nullstack/b6f69c3da1fe0952166c8eac4ca0361473a2362c/client.css" integrity="" crossorigin="anonymous">
    
    <link rel="apple-touch-icon" sizes="180x180" href="/icon-180x180.png">
    <meta name="msapplication-TileColor" content="#D22365">
    <link href="https://fonts.gstatic.com" rel="preconnect"/><link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  </head>
  <body>
    <div id="application"><main class="bg-tips-light"><div><!----><!----><script async src="https://www.googletagmanager.com/gtag/js?id=AW-641358523"></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-120538403-3"></script></div><!-- --><!----><!----><!----><!----><!----><!----><!----><!----><header class="fixed w-full bg-white top-0 left-0 z-50 h-20"><div class="max-w-screen-xl mx-auto px-4 flex justify-between items-center flex-wrap py-4"><div class="w-full sm:w-auto justify-between sm:justify-self-start sm:px-0 items-center flex"><a href="/"><img src="/tipscode-logo-1.svg" alt="TipsCode" width="155" height="44"/></a><span class="flex items-center sm:hidden"><svg height="20" class="text-tips-gray-dark text-opacity-60" viewBox="0 0 512 512"><!----><!----><rect x="10" y="10" width="492" height="90.4043" rx="17.383" stroke-width="20" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="none"></rect><rect x="10" y="411.5957" width="492" height="90.4043" rx="17.383" stroke-width="20" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="none"></rect><rect x="10" y="210.7979" width="492" height="90.4043" rx="17.383" stroke-width="20" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="none"></rect></svg></span></div><nav class="flex items-center flex-wrap sm:px-0 mt-2 sm:mt-0 z-50 bg-white hidden sm:flex"><a href="/" class="w-full sm:w-auto text-tips-gray-dark border-b sm:border-0 border-gray-100 p-2 font-lg hover:text-tips-blue items-center flex"> Home <!--#--></a><a href="/artigos" class="w-full sm:w-auto text-tips-gray-dark border-b sm:border-0 border-gray-100 p-2 font-lg hover:text-tips-blue items-center flex"> Blog <!--#--></a><a href="/ebook-gratuito" class="w-full sm:w-auto text-tips-gray-dark border-b sm:border-0 border-gray-100 p-2 font-lg hover:text-tips-blue items-center flex"> E-book Gratuito <!--#--></a><a href="/mini-curso-gratuito" class="w-full sm:w-auto text-tips-gray-dark border-b sm:border-0 border-gray-100 p-2 font-lg hover:text-tips-blue items-center flex"> Mini-Curso Gratuito <!--#--></a></nav><div class="flex w-full sm:w-auto mt-4 sm:mt-0 hidden sm:flex"><a href="/curso-fullstack-turbo" class="bg-tips-blue text-white px-3 py-2 border border-tips-blue rounded hover:bg-white hover:text-tips-blue w-full sm:w-auto">Full-Stack Turbo<!--#--></a></div></div></header><div class="h-20"></div><div class="max-w-screen-xl mx-auto sm:m-auto sm:text-justify px-4 py-16"><article><h1 class="font-bold text-4xl text-left sm:text-left"> <!--#-->Event Loop NodeJS: Um Guia Completo Para Iniciante<!--#--> <!--#--></h1><figure class="mt-10"><img width="1242" src="/thumbnail-article/event-loop-nodejs.png"/><ficaption><!----></ficaption></figure><div class="mt-10 prose max-w-none"><p>A assincronia em qualquer linguagem de programação é difícil e o <strong>event loop</strong> vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware.</p>
<p>JavaScript é de thread única, mas isso limita o Node de utilizar arquitetura moderna? Um dos maiores desafios é lidar com várias threads por causa de sua complexidade inerente. Criar novas threads e gerenciar a troca de contexto entre elas é caro. Tanto o sistema operacional quanto o programador devem trabalhar muito para fornecer uma solução. Neste artigo, mostrarei como o Node lida com <strong>event loop</strong>. Explorarei cada parte do event loop do Node.js e demonstrarei como ele funciona. Um dos recursos melhores recursos do Node é o event loop, porque ele resolveu um problema difícil de uma maneira inovadora</p>
<h2>Event Loop</h2>
<p>O <strong>event loop</strong> é um loop simultâneo de thread única, sem bloqueio e de forma assíncrona. Imagine uma solicitação web que faz uma pesquisa no banco de dados. Uma única <strong>thread</strong> só pode fazer uma coisa de cada vez. Em vez de aguardar a resposta do banco de dados, ele continua a selecionar outras tarefas na fila. No <strong>event loop</strong>, o loop principal desenrola a pilha de chamadas e não espera os retornos de chamada. Como o loop não bloqueia, é tranquilo fazer mais de uma solicitação web por vez. Várias solicitações podem ser enfileiradas ao mesmo tempo, o que as torna simultâneas. O event loop não espera que uma solicitação seja concluído, mas pega retornos de chamada conforme eles vêm, sem bloqueio.</p>
<p>O <strong>event loop</strong> em si é semi-infinito, o que significa que se a pilha de chamadas ou a fila de retorno de chamada estiverem vazias, ele pode sair do loop. Pense na pilha de chamadas como um código síncrono que se desenrola, como console.log, antes que o loop busque mais trabalho. O Node usa <strong>libuv</strong> por baixo dos panos para pesquisar no sistema operacional em busca de retornos de chamada de conexões de entrada.</p>
<p>Você pode estar se perguntando, por que o event loop é executado em uma única thread? <strong>Threads</strong> são relativamente pesados ​​na memória para os dados de que necessita por conexão. Threads são recursos do sistema operacional que aumentam e isso não é escalonável para milhares de conexões ativas.</p>
<p>Vários tópicos em geral também complicam a história. Se um retorno de chamada retornar com dados, ele deve empacotar o contexto de volta para a thread que está em execução. A troca de contexto entre threads é lenta, porque deve sincronizar o estado atual, como a pilha de chamadas ou variáveis ​​locais. O event loop elimina os bugs quando várias threads compartilham recursos, porque é thread única. Um loop de thread única corta casos extremos de segurança de thread e pode mudar de contexto muito mais rápido. Este é o verdadeiro lance por trás do event loop. Ele faz uso efetivo de conexões e threads enquanto permanece escalável.</p>
<h2>Loop Semi-infinito</h2>
<p>A maior pergunta que o event loop deve responder é se o loop está ativo. Em caso afirmativo, ele descobre quanto tempo deve esperar na fila de retorno de chamada. A cada iteração, o loop desenrola a pilha de chamadas e, em seguida, pesquisa.</p>
<p>Aqui está um exemplo que bloqueia o loop principal:</p>
<pre><code><span class="token function">setTimeout</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Oi a fila de retorno'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mantenha o loop ativo por x tempo</span>

<span class="token keyword">const</span> stopTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> stopTime<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// Bloqueie o loop principal</span>
</code></pre>
<p>Se você executar este código, observe que o loop fica bloqueado por dois segundos. Mas o loop permanece ativo até que o retorno de chamada seja executado em cinco segundos. Depois que o loop principal é desbloqueado, o mecanismo de pesquisa descobre quanto tempo ele espera nos retornos de chamada. Esse loop termina quando a pilha de chamadas é desfeita e não há mais retornos de chamada restantes.</p>
<h2>A fila de retorno de chamada</h2>
<p>Agora, o que acontece quando eu bloqueio o loop principal e agendo um retorno de chamada? Uma vez que o loop é bloqueado, ele não coloca mais callbacks na fila:</p>
<pre><code><span class="token keyword">const</span> stopTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> stopTime<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// Bloqueie o loop principal</span>

<span class="token comment">// Isso leva 7 segundos para ser executado</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Executou callback A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Desta vez, o loop permanece ativo por sete segundos. O event loop é burro em sua simplicidade. Ele não tem como saber o que pode ser colocado na fila no futuro. Em um sistema real, os retornos de chamada de entrada são enfileirados e executados, pois o loop principal está livre para pesquisar. O event loop passa por várias fases <em>sequencialmente</em> quando é desbloqueado. Portanto, para vencer aquela entrevista de emprego sobre o loop, evite jargões sofisticados como “emissor de evento” ou “padrão de reator”. É um humilde loop de thread único, simultâneo e não bloqueador, não precisa querer complica, lembre-se o simples é poderoso.</p>
<h2>O Event Loop assíncrono / espera</h2>
<p>Para evitar o bloqueio do loop principal, uma ideia é envolver a E / S síncrona em torno do recurso async / await. Caso esteja procurando um bom curso / treinamento de NodeJS te <a href="/programador-fullstack-8-semanas">recomendo esse aqui</a>.</p>
<pre><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">readFileSync</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">await</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'readme.md'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'O event loop continua sem bloqueio...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Tudo o que vier depois de <strong>await</strong> vem da fila de retorno de chamada. O código é lido como um código de bloqueio síncrono, mas não bloqueia. Note que async / <a href="https://youtu.be/IR9azXeWs2s" target="_blank" rel="noopener">readFileSync</a> await o torna possível, o que o tira do loop principal. Pense em tudo o que vem depois await como não-bloqueador por meio de um retorno de chamada.</p>
<p>O código acima é apenas para fins de demonstração. Em código real, eu recomendo <a href="https://youtu.be/IR9azXeWs2s" target="_blank" rel="noopener">fs.readFile</a>, que dispara um retorno de chamada que pode envolver uma <a href="https://youtu.be/fRa33RSJpSo" target="_blank" rel="noopener">promise</a>. A intenção geral ainda é válida, porque isso tira o bloqueio de E / S do loop principal.</p>
<h2>Mais detalhes sobre</h2>
<p>E se eu dissesse que o <strong>event loop</strong> tem mais do que uma pilha de chamada e mais uma fila de retorno de chamada? E se o <strong>event loop</strong> não fosse apenas um loop, mas muitos?</p>
<p>Agora, quero levá-lo para trás da fachada e para visualiza com mais detalhes os componentes internos do <a href="/conhecendo-nodejs/">NodeJS</a></p>
<h2>Fases do Event Loop</h2>
<p>Estas são as fases do <strong>Event Loop</strong>:</p>
<p><img src="/uploads/2020/09/event-loop.png" alt="event loop
"></p>
<p>Estrutura event loop</p>
<p>1 . Ás datas / hora são atualizadas. O <strong>Event loop</strong> armazena em cache a hora atual no início do loop para evitar chamadas de sistema frequentes relacionadas ao tempo. Essas chamadas de sistema são internas à <strong>libuv</strong>.</p>
<p>2 . O loop está vivo? Se o loop tiver identificadores ativos, solicitações ativas ou identificadores de fechamento, ele está vivo. Conforme mostrado, retornos de chamada pendentes na fila mantêm o loop ativo.</p>
<p>3 . Os cronômetros de vencimento são executados. Este é o lugar onde o <strong>setTimeout</strong>() ou <strong>setInterval</strong>() retornos de chamada executada. O loop verifica o cache se tem <strong>callbacks</strong> ativos que expiraram em execução.</p>
<p>4 . Retornos de chamada pendentes na fila são executados. Se a iteração anterior adiou quaisquer retornos de chamada, eles serão executados neste ponto. O <strong>polling</strong> normalmente executa <strong>callbacks</strong> de E / S imediatamente, mas há exceções. Esta etapa lida com quaisquer retardatários da iteração anterior.</p>
<p>5 . Manipuladores ociosos são executados - principalmente a partir de nomenclatura inadequada, porque eles são executados a cada iteração e são internos ao libuv.</p>
<p>6 . Prepare identificadores para <strong>setImmediate()</strong> execução de retorno de chamada na iteração do loop. Esses identificadores são executados antes dos blocos do loop para E / S e preparam a fila para esse tipo de retorno de chamada.</p>
<p>7 . Calcule o tempo limite da votação. O loop deve saber quanto tempo ele bloqueia para E / S. É assim que ele calcula o tempo limite:</p>
<ul>
<li>Se o loop estiver prestes a sair, o tempo limite é 0;</li>
<li>Se não houver identificadores ou solicitações ativas, o tempo limite será 0;</li>
<li>Se houver algum identificador inativo, o tempo limite é 0;</li>
<li>Se houver algum identificador pendente na fila, o tempo limite será 0;</li>
<li>Se houver alguma fechamento, o tempo limite é 0;</li>
<li>Se nenhuma das opções acima, o tempo limite é definido para o temporizador mais próximo ou, se não houver temporizadores ativos, infinito.</li>
</ul>
<p>8 . O loop bloqueia para E / S com a duração da fase anterior. Os retornos de chamada relacionados a E / S na fila são executados neste ponto.</p>
<p>9 . Verifique a execução de callbacks do identificador. Esta fase é onde <strong>setImmediate()</strong> funciona e é a contrapartida para preparar. Quaisquer <strong>setImmediate()</strong> retornos de chamada enfileirados no meio da execução de retorno de chamada de E / S são executados aqui.</p>
<p>10 . Fechar callbacks são executados. Esses são identificadores ativos descartados de conexões fechadas.</p>
<p>11 . A iteração termina.</p>
<p>Você deve estar se perguntando por que a pesquisa bloqueia E / S quando deveria ser sem bloqueio? O loop bloqueia apenas quando não há retornos de chamada pendentes na fila e a pilha de chamadas está vazia. No Node, o temporizador mais próximo pode ser definido por <strong>setTimeout</strong>, por exemplo. Se definido como infinito, o loop espera nas conexões de entrada com mais trabalho. É um loop semi-infinito, porque a pesquisa mantém o loop ativo quando não há mais nada a fazer e há uma conexão ativa.</p>
<p>Aqui está a versão Unix deste cálculo de tempo limite é toda a sua glória C:</p>
<pre><code>int <span class="token function">uv_backend_timeout</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">const</span> uv_loop_t<span class="token operator">*</span> loop</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-</span><span class="token operator">></span>stop_flag <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">uv__has_active_handles</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">uv__has_active_reqs</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>idle_handles<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">QUEUE_EMPTY</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>loop<span class="token operator">-</span><span class="token operator">></span>pending_queue<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>loop<span class="token operator">-</span><span class="token operator">></span>closing_handles<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token function">uv__next_timeout</span><span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Você pode não estar muito familiarizado com C, mas parece inglês e faz exatamente o que está na fase sete.</p>
<h2>Uma demonstração fase a fase</h2>
<p>Para mostrar cada fase em JavaScript simples:</p>
<pre><code><span class="token comment">// 1. Loop começa, o timestamps é atualizados</span>
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2. O loop permanece vivo se houver código na pilha de chamadas para desenrolar</span>
<span class="token comment">// 8. Pesquisar E / S e executar este retorno de chamada de conexões de entrada</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// O retorno de chamada de E / S da rede é executado imediatamente após a pesquisa</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Mantenha o loop ativo se houver uma conexão aberta</span>
<span class="token comment">// 7. Se não houver mais nada a fazer, calcule o tempo limite</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// Evite uma consulta DNS para ficar fora do pool de threads</span>
  <span class="token literal-property property">hostname</span><span class="token operator">:</span> <span class="token string">'192.0.2.1'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">port</span><span class="token operator">:</span> <span class="token number">3000</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">sendHttpRequest</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// Callbacks de E / S de rede executados na fase 8</span>
  <span class="token comment">// Callbacks de E / S de arquivo executados na fase 4</span>
  <span class="token keyword">const</span> req <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Resposta recebida do servidor'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 9. Executar verificação de retorno de chamada</span>
    <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
      <span class="token comment">// 10. Feche a execução da callback</span>
       server<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token comment">// O fim. ALERTA DE SPOILER! O Loop morre no final.</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Fechando servidor'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  req<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 3. O cronômetro é executado em 8 segundos, enquanto o loop permanece ativo</span>
<span class="token comment">// O tempo limite calculado antes da votação o mantém ativo</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">sendHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 11. Fim da iteração..</span>
</code></pre>
<p>Como os callbacks de E / S de arquivo são executados na fase quatro e antes da fase nove, espere <strong>setImmediate()</strong> disparar primeiro:</p>
<pre><code>fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'leiame.md'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Arquivo I/O callback via setTimeout()'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Este retorno de chamada é executado primeiro</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Arquivo I/O callback via setImmediate()'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>A E / S de rede sem uma pesquisa de DNS é menos cara do que a E / S de arquivo, porque é executada no <strong>event loop</strong> principal. Em vez disso, a E / S do arquivo é enfileirada por meio do pool de threads. Uma pesquisa de DNS também usa o pool de threads, então isso torna a E / S de rede tão cara quanto a E / S de arquivo.</p>
<h2>Pool de Thread - Event loop</h2>
<p>Os componentes internos do nó têm duas partes principais: o mecanismo JavaScript V8 e o libuv. E / S de arquivo, pesquisa de DNS e E / S de rede acontecem via libuv.</p>
<p>Esta é a arquitetura geral:</p>
<p><img src="/uploads/2020/09/libuv.png" alt=""></p>
<p>Fonte da imagem: documentação do <a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a></p>
<p>Para E / S de rede, o <strong>event loop</strong> pesquisa dentro do encadeamento principal. A thread não é segura para threads porque não muda de contexto com outro thread. A E / S de arquivo e a pesquisa de DNS são específicas da plataforma, portanto, a abordagem é executá-los em um pool de threads. Uma ideia é fazer a pesquisa de DNS você mesmo para ficar fora do pool de threads, conforme mostrado no código acima. Colocar um endereço IP versus localhost, por exemplo, tira a pesquisa do pool. O pool de threads tem um número limitado de threads disponíveis, que pode ser definido por UV_THREADPOOL_SIZEmeio da variável de ambiente. O tamanho do pool de threads padrão é cerca de quatro.</p>
<p>O V8 é executado em um loop separado, esvazia a pilha de chamadas e devolve o controle ao event loop. O V8 pode usar vários encadeamentos para coleta de lixo fora de seu próprio loop. Pense no V8 como o mecanismo que recebe JavaScript bruto e o executa no hardware.</p>
<p>Para o programador médio, o JavaScript permanece com thread único porque não há segurança de thread. V8 e libuv internos giram seus próprios threads separados para atender às suas próprias necessidades.</p>
<p>Se houver problemas de taxa de transferência no Node, comece com o event loop principal. Verifique quanto tempo leva para a aplicação concluir uma única iteração. Não deve durar mais do que cem milissegundos. Em seguida, verifique se há inanição do pool de encadeamentos e o que pode ser despejado do pool. Também é possível aumentar o tamanho do pool por meio da variável de ambiente. A última etapa é fazer um microbenchmark do código JavaScript no V8 que é executado de forma síncrona.</p>
<h2>Empacotando</h2>
<p>O event loop continua a iterar em cada fase à medida que os retornos de chamada são enfileirados. Mas, dentro de cada fase, há uma maneira de enfileirar outro tipo de retorno de chamada.</p>
<p><strong>process.nextTick()</strong> vs <strong>setImmediate()</strong></p>
<p>No final de cada fase, o loop executa o <strong>process.nextTick()</strong> retorno de chamada. Observe que esse tipo de retorno de chamada não faz parte do event loop porque é executado no final de cada fase. O <a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">setImmediate()</a> retorno de chamada faz parte do loop geral de eventos, portanto, não é tão imediato quanto o nome indica. Como <strong>process.nextTick()</strong> precisa de conhecimento avançado de event loop <a href="/programador-fullstack-8-semanas">clique aqui caso queira ir para o próximo nível em nodejs</a>, recomendo o uso <strong>setImmediate()</strong> em geral.</p>
<p>Existem alguns motivos pelos quais você pode precisar <strong>process.nextTick():</strong></p>
<ul>
<li>Permita que a E / S da rede lide com erros, limpe ou tente a solicitação novamente antes que o loop continue;</li>
<li>Pode ser necessário executar um retorno de chamada após o desenrolar da pilha de chamadas, mas antes que o loop continue.</li>
</ul>
<p>Digamos, por exemplo, que um emissor de evento deseja disparar um evento enquanto ainda está em seu próprio construtor. A pilha de chamadas deve ser desenrolada antes de chamar o evento.</p>
<pre><code><span class="token keyword">const</span> EventEmitter <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'eventos'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ImpatientEmitter</span> <span class="token keyword">extends</span> <span class="token class-name">EventEmitter</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Acione isso no final da fase com uma pilha de chamadas desfeita</span>
    process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'eventos'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> emitter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImpatientEmitter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
emitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Ocorreu um evento impaciente!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Permitir que a pilha de chamadas seja desenrolada pode evitar erros como RangeError: Maximum call stack size exceeded. Uma pegadinha é ter certeza de process.nextTick()que não bloqueia o event loop O bloqueio pode ser problemático com chamadas de retorno de chamada recursivas na mesma fase.</p>
<h2>Conclusão</h2>
<p>O event loop é a simplicidade em sua sofisticação final. É preciso um problema difícil, como assincronia, segurança de thread e simultaneidade. Ele remove o que não ajuda ou o que não precisa e maximiza o rendimento da maneira mais eficaz possível. Por causa disso, os programadores de Node gastam menos tempo com bugs assíncronos e mais tempo entregando novos recursos.</p>
<h2>Recomendado</h2>
</div></article></div><sectino class="px-4 sm:max-w-screen-xl sm:mx-auto sm:items-center flex sm:justify-between mt-10"><div class="flex flex-wrap shadow rounded-lg w-full bg-gradient-to-r from-tips-blue to-purple-500 focus:from-pink-500 focus:to-yellow-500 p-8"><div class="flex flex-wrap flex-col sm:flex-row items-center"><figure class="w-full sm:w-1/2"><img src="/banner-img.png" alt="Estudante TipsCode" width="440" height="454"/></figure><div class="w-full md:w-1/2"><h2 class="text-tips-light text-lg md:text-3xl font-semibold mb-3 leading-relaxed traking-wide">Vagas abertas para o melhor curso de programção <!--#--><strong>Fullstack<!--#--></strong> do Brasil. Clique no botão abaixo para conhecer.<!--#--></h2><div class="mt-2"><a href="https://bit.ly/2YivXeS" class="inline-block text-center w-full sm:w-auto lg:mx-0 bg-tips-green text-white font-bold rounded mt-4 lg:mt-0 py-2 px-8 shadow focus:outline-none focus:shadow-outline transform transition hover:scale-105 duration-300 ease-in-out">Conhecer Treinamento<!--#--></a></div></div></div></div></sectino><footer class="flex flex-col items-center py-16 sm:flex-row sm:justify-around"><figure class="flex-col sm:flex sm:justify-start"><a href="/"><img src="./tipscode-logo-1.svg" class="m-auto sm:m-0 md:m-0 lg:m-0" alt="TipsCode" width="186" height="66" loading="lazy"/></a><p class="text-center sm:text-center w-full text-tips-dark text-opacity-80">Todos os direitos reservados - TipsCode<!--#--><strong class="text-center sm:text-left w-full block">CNPJ:41.562.138/0001-61<!--#--></strong></p></figure><div class="flex flex-wrap justify-center my-8 sm:my-0"><div><a href="https://nullstack.app" target="_blank" rel="noopener noreferrer" class="flex justify-center flex-wrap" title="Desenvolvido com Nullstack"><span class="w-full block text-center text-tips-dark text-opacity-80"> Desenvolvido com <!--#--></span><svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 511.5039 113.7368"><title> Nullstack <!--#--></title><path d="M13.2736,39.964H28.7009v9.8922a20.3919,20.3919,0,0,1,7.743-8.479,21.2792,21.2792,0,0,1,11.2172-3.0031q7.36,0,11.3349,4.1218t3.9745,11.6588a48.9655,48.9655,0,0,1-1.06,8.8913l-8.3025,42.8665H36.3556L44.187,65.7546a31.2306,31.2306,0,0,0,.5888-5.5939q0-7.6542-6.3593-7.6547a10.7348,10.7348,0,0,0-8.4791,4.3278q-3.5922,4.328-5.0639,12.0415l-7.1248,37.0372H.4961Z" transform="translate(-0.4961)" fill="#2d3748"></path><path d="M81.4691,107.62q-7.2426,0-11.2466-4.1807t-4.004-11.8943a46.3965,46.3965,0,0,1,1.001-8.6557L75.64,39.964H92.7746L85.0609,80.24a29.8175,29.8175,0,0,0-.5888,5.5938q0,7.6551,6.4771,7.6548A10.3547,10.3547,0,0,0,99.2811,89.19q3.4446-4.2978,4.9756-12.0709L111.44,39.964h17.1348l-12.7775,65.9485H100.37V96.138a18.7565,18.7565,0,0,1-7.4781,8.3908A21.4849,21.4849,0,0,1,81.4691,107.62Z" transform="translate(-0.4961)" fill="#2d3748"></path><path d="M150.2958,113.7368q-11.4821,0-16.7815-3.3563t-5.2995-10.5989a43.049,43.049,0,0,1,1.1188-8.3613l11.9532-56.6451H123.2687l2.532-13.2486h35.2118L146.2918,92.4213q-.1767.825-.3238,1.7371a10.5763,10.5763,0,0,0-.1473,1.6781q0,4.6521,8.2436,4.6517h16.3694l-2.65,13.2486Z" transform="translate(-0.4961)" fill="#d22365"></path><path d="M181.897,92.21q-11.4822,0-16.7816-3.3563T159.816,78.255a43.0455,43.0455,0,0,1,1.1187-8.3613l11.9532-56.6451H154.87L157.4018,0h35.2118L177.8929,70.8947q-.1765.8248-.3238,1.737a10.5766,10.5766,0,0,0-.1472,1.6782q0,4.6519,8.2435,4.6517h16.3694l-2.65,13.2486Z" transform="translate(-0.4961)" fill="#d22365"></path><path d="M228.3106,107.62a72.47,72.47,0,0,1-23.6119-4.1218l3.003-15.0739q10.5988,6.7717,21.6688,6.7715,6.4176,0,10.0983-2.2965a7.1387,7.1387,0,0,0,3.68-6.3593,4.4873,4.4873,0,0,0-1.8253-3.8273q-2.3556-1.884-9.5979-3.9452l-5.1817-1.4132q-13.8969-3.8271-13.8963-16.9582a18.9819,18.9819,0,0,1,8.0375-16.0455q8.0374-5.976,22.4637-5.9766a60.6829,60.6829,0,0,1,10.1573.8538,63.0434,63.0434,0,0,1,10.5105,2.797L260.8727,56.981a33.7,33.7,0,0,0-19.3724-6.3q-5.9478,0-9.3623,2.09a6.2659,6.2659,0,0,0-3.4152,5.5056,5.102,5.102,0,0,0,2.2375,4.2984q2.4731,1.7082,9.6568,3.7685l4.3573,1.2365q7.4775,2.12,10.9816,6.271t3.5035,10.805q0,10.7172-8.2436,16.84T228.3106,107.62Z" transform="translate(-0.4961)" fill="#2d3748"></path><path d="M297.9546,106.2069q-11.3055,0-16.6932-3.3857t-5.3878-10.57a47.7847,47.7847,0,0,1,1.06-8.3613l5.9472-30.6778H265.9813l2.532-13.2486h16.8993l3.5918-18.7247h17.2527L302.6063,39.964h22.5521l-2.532,13.2486h-22.552l-6.1827,31.6788A20.2915,20.2915,0,0,0,293.48,88.13a3.9534,3.9534,0,0,0,1.9431,3.68q1.9433,1.1482,6.2416,1.1482h13.2486l-2.532,13.2486Z" transform="translate(-0.4961)" fill="#2d3748"></path><path d="M338.2138,107.62q-9.4224,0-14.6029-5.1228-5.1828-5.1228-5.1816-14.25,0-12.2469,9.3034-18.99t26.2617-6.7421h11.3643l.4711-2.8852a3.6427,3.6427,0,0,1,.1177-.7066v-1.001A5.6271,5.6271,0,0,0,362.974,52.8q-2.9748-1.7666-8.5086-1.7665a41.5275,41.5275,0,0,0-10.8933,1.59,85.9338,85.9338,0,0,0-13.3074,5.0639l2.7675-14.7206a74.3941,74.3941,0,0,1,24.6129-4.5929q12.07,0,18.6363,4.6518,6.5643,4.652,6.5655,13.72a36.323,36.323,0,0,1-.4711,5.5939q-.4716,3.003-1.1188,5.9471l-7.2425,37.626H358.47v-7.36A26.3115,26.3115,0,0,1,338.2138,107.62Zm7.1837-11.8354q6.476,0,11.2466-5.6822t6.3-15.3978h-6.6537q-19.9029,0-19.9023,12.13a8.3352,8.3352,0,0,0,9.009,8.95Z" transform="translate(-0.4961)" fill="#2d3748"></path><path d="M415.1828,107.62q-13.72,0-21.1683-7.4192t-7.4486-21.4333a42.63,42.63,0,0,1,5.005-20.8444,36.7663,36.7663,0,0,1,13.9257-14.338,40.3978,40.3978,0,0,1,20.7562-5.2111A39.0215,39.0215,0,0,1,445.8607,43.32l-3.1208,15.78a22.7112,22.7112,0,0,0-16.075-6.7126,21.2393,21.2393,0,0,0-11.8059,3.2974A22.52,22.52,0,0,0,406.88,64.783a29.416,29.416,0,0,0-2.8853,13.278q0,8.0083,3.4741,11.7765T417.95,93.606q8.8324,0,19.3724-6.1238l-3.2974,16.2516A45.998,45.998,0,0,1,415.1828,107.62Z" transform="translate(-0.4961)" fill="#2d3748"></path><path d="M458.1224,14.2911H475.375l-8.95,46.0463L490.2134,39.964H512L482.2643,64.5769l18.43,41.3356H482.382L469.31,75.058l-6.83,5.6527-4.8284,25.2018H440.3987Z" transform="translate(-0.4961)" fill="#2d3748"></path></svg></a></div></div><ul><li class="inline-block ml-4"><a href="https://web.facebook.com/tipscodeoficial" title="tipscodeoficial" target="_blank" rel="noreferrer" class="text-tips-blue hover:text-tips-green"><svg width="24" height="24" fill="#F5F5FF" viewBox="0 0 24 24"><path d="M18 2H15C13.6739 2 12.4021 2.52678 11.4645 3.46447C10.5268 4.40215 10 5.67392 10 7V10H7V14H10V22H14V14H17L18 10H14V7C14 6.73478 14.1054 6.48043 14.2929 6.29289C14.4804 6.10536 14.7348 6 15 6H18V2Z" stroke="#2B293F" stroke-opacity="0.6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></a></li><li class="inline-block ml-4"><a href="https://github.com/alissonsuassuna" title="alissonsuassuna" target="_blank" rel="noreferrer" class="text-tips-blue hover:text-tips-green"><svg width="24" height="24" fill="#F5F5FF" viewBox="0 0 24 24"><path d="M16 21.9999V18.1299C16.0375 17.6531 15.9731 17.1737 15.811 16.7237C15.6489 16.2737 15.3929 15.8634 15.06 15.5199C18.2 15.1699 21.5 13.9799 21.5 8.51994C21.4997 7.12376 20.9627 5.78114 20 4.76994C20.4559 3.54844 20.4236 2.19829 19.91 0.999938C19.91 0.999938 18.73 0.649938 16 2.47994C13.708 1.85876 11.292 1.85876 9 2.47994C6.27 0.649938 5.09 0.999938 5.09 0.999938C4.57638 2.19829 4.54414 3.54844 5 4.76994C4.03013 5.78864 3.49252 7.1434 3.5 8.54994C3.5 13.9699 6.8 15.1599 9.94 15.5499C9.611 15.8899 9.35726 16.2953 9.19531 16.7399C9.03335 17.1844 8.96681 17.658 9 18.1299V21.9999M9 18.9999C4 20.4999 4 16.4999 2 15.9999L9 18.9999Z" stroke="#2B293F" stroke-opacity="0.6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></a></li><li class="inline-block ml-4"><a href="https://www.youtube.com/tipscode" title="tipscode" target="_blank" rel="noreferrer" class="text-tips-blue hover:text-tips-green"><svg width="24" height="24" viewBox="0 0 24 24" fill="#F5F5FF" xmlns="http://www.w3.org/2000/svg"><path d="M22.54 6.42C22.4212 5.94541 22.1792 5.51057 21.8386 5.15941C21.498 4.80824 21.0707 4.55318 20.6 4.42C18.88 4 12 4 12 4C12 4 5.11996 4 3.39996 4.46C2.92921 4.59318 2.50194 4.84824 2.16131 5.19941C1.82068 5.55057 1.57875 5.98541 1.45996 6.46C1.14518 8.20556 0.991197 9.97631 0.999961 11.75C0.988741 13.537 1.14273 15.3213 1.45996 17.08C1.59092 17.5398 1.83827 17.9581 2.17811 18.2945C2.51794 18.6308 2.93878 18.8738 3.39996 19C5.11996 19.46 12 19.46 12 19.46C12 19.46 18.88 19.46 20.6 19C21.0707 18.8668 21.498 18.6118 21.8386 18.2606C22.1792 17.9094 22.4212 17.4746 22.54 17C22.8523 15.2676 23.0063 13.5103 23 11.75C23.0112 9.96295 22.8572 8.1787 22.54 6.42V6.42Z" stroke="#2B293F" stroke-opacity="0.6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M9.75 15.02L15.5 11.75L9.75 8.47998V15.02Z" stroke="#2B293F" stroke-opacity="0.6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></a></li><li class="inline-block ml-4"><a href="https://www.instagram.com/tipscodeoficial" title="tipscodeoficial" target="_blank" rel="noreferrer" class="text-tips-blue hover:text-tips-green"><svg width="24" height="24" viewBox="0 0 24 24" fill="#F5F5FF" xmlns="http://www.w3.org/2000/svg"><path d="M17 2H7C4.23858 2 2 4.23858 2 7V17C2 19.7614 4.23858 22 7 22H17C19.7614 22 22 19.7614 22 17V7C22 4.23858 19.7614 2 17 2Z" stroke="#2B293F" stroke-opacity="0.6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M16 11.3698C16.1234 12.2021 15.9812 13.052 15.5937 13.7988C15.2062 14.5456 14.5931 15.1512 13.8416 15.5295C13.0901 15.9077 12.2384 16.0394 11.4077 15.9057C10.5771 15.7721 9.80971 15.3799 9.21479 14.785C8.61987 14.1901 8.22768 13.4227 8.09402 12.592C7.96035 11.7614 8.09202 10.9097 8.47028 10.1582C8.84854 9.40667 9.45414 8.79355 10.2009 8.40605C10.9477 8.01856 11.7977 7.8764 12.63 7.99981C13.4789 8.1257 14.2648 8.52128 14.8716 9.12812C15.4785 9.73496 15.8741 10.5209 16 11.3698Z" stroke="#2B293F" stroke-opacity="0.6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path><path d="M17.5 6.5H17.51" stroke="#2B293F" stroke-opacity="0.6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></a></li><li class="inline-block ml-4"><a href="https://twitter.com/alissonsuassuna" title="alissonsuassuna" target="_blank" rel="noreferrer" class="text-tips-blue hover:text-tips-green"><svg width="24" height="24" fill="#F5F5FF" viewBox="0 0 24 24"><path d="M23 2.9998C22.0424 3.67528 20.9821 4.19191 19.86 4.5298C19.2577 3.83731 18.4573 3.34649 17.567 3.12373C16.6767 2.90096 15.7395 2.957 14.8821 3.28426C14.0247 3.61151 13.2884 4.1942 12.773 4.95352C12.2575 5.71283 11.9877 6.61214 12 7.5298V8.5298C10.2426 8.57537 8.50127 8.18561 6.93101 7.39525C5.36074 6.60488 4.01032 5.43844 3 3.9998C3 3.9998 -1 12.9998 8 16.9998C5.94053 18.3978 3.48716 19.0987 1 18.9998C10 23.9998 21 18.9998 21 7.4998C20.9991 7.22126 20.9723 6.9434 20.92 6.6698C21.9406 5.6633 22.6608 4.39251 23 2.9998V2.9998Z" stroke="#2B293F" stroke-opacity="0.6" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></a></li></ul></footer><span href="/obrigado-por-entrar-no-mini-curso"> <!--#--></span><span href="/aulas-do-mini-curso"> <!--#--></span></main></div>
    <script async>
      window.page = {"image":"/thumbnail-article/event-loop-nodejs.png","status":200,"locale":"pt-BR","title":"Event Loop NodeJS: Um Guia Completo Para Iniciante - TipsCode","description":"A assincronia em qualquer linguagem de programação é difícil e o event loop vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware."};
      window.instances = {"application":{},"n-0-0-0-0":{},"n-0-0-0-1":{},"n-0-0-0-2":{},"n-0-0-0-3":{},"n-0-0-10/event-loop-em-node-guia-completo":{"slug":"event-loop-em-node-guia-completo","content":"<p>A assincronia em qualquer linguagem de programação é difícil e o <strong>event loop<\/strong> vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware.<\/p>\n<p>JavaScript é de thread única, mas isso limita o Node de utilizar arquitetura moderna? Um dos maiores desafios é lidar com várias threads por causa de sua complexidade inerente. Criar novas threads e gerenciar a troca de contexto entre elas é caro. Tanto o sistema operacional quanto o programador devem trabalhar muito para fornecer uma solução. Neste artigo, mostrarei como o Node lida com <strong>event loop<\/strong>. Explorarei cada parte do event loop do Node.js e demonstrarei como ele funciona. Um dos recursos melhores recursos do Node é o event loop, porque ele resolveu um problema difícil de uma maneira inovadora<\/p>\n<h2>Event Loop<\/h2>\n<p>O <strong>event loop<\/strong> é um loop simultâneo de thread única, sem bloqueio e de forma assíncrona. Imagine uma solicitação web que faz uma pesquisa no banco de dados. Uma única <strong>thread<\/strong> só pode fazer uma coisa de cada vez. Em vez de aguardar a resposta do banco de dados, ele continua a selecionar outras tarefas na fila. No <strong>event loop<\/strong>, o loop principal desenrola a pilha de chamadas e não espera os retornos de chamada. Como o loop não bloqueia, é tranquilo fazer mais de uma solicitação web por vez. Várias solicitações podem ser enfileiradas ao mesmo tempo, o que as torna simultâneas. O event loop não espera que uma solicitação seja concluído, mas pega retornos de chamada conforme eles vêm, sem bloqueio.<\/p>\n<p>O <strong>event loop<\/strong> em si é semi-infinito, o que significa que se a pilha de chamadas ou a fila de retorno de chamada estiverem vazias, ele pode sair do loop. Pense na pilha de chamadas como um código síncrono que se desenrola, como console.log, antes que o loop busque mais trabalho. O Node usa <strong>libuv<\/strong> por baixo dos panos para pesquisar no sistema operacional em busca de retornos de chamada de conexões de entrada.<\/p>\n<p>Você pode estar se perguntando, por que o event loop é executado em uma única thread? <strong>Threads<\/strong> são relativamente pesados ​​na memória para os dados de que necessita por conexão. Threads são recursos do sistema operacional que aumentam e isso não é escalonável para milhares de conexões ativas.<\/p>\n<p>Vários tópicos em geral também complicam a história. Se um retorno de chamada retornar com dados, ele deve empacotar o contexto de volta para a thread que está em execução. A troca de contexto entre threads é lenta, porque deve sincronizar o estado atual, como a pilha de chamadas ou variáveis ​​locais. O event loop elimina os bugs quando várias threads compartilham recursos, porque é thread única. Um loop de thread única corta casos extremos de segurança de thread e pode mudar de contexto muito mais rápido. Este é o verdadeiro lance por trás do event loop. Ele faz uso efetivo de conexões e threads enquanto permanece escalável.<\/p>\n<h2>Loop Semi-infinito<\/h2>\n<p>A maior pergunta que o event loop deve responder é se o loop está ativo. Em caso afirmativo, ele descobre quanto tempo deve esperar na fila de retorno de chamada. A cada iteração, o loop desenrola a pilha de chamadas e, em seguida, pesquisa.<\/p>\n<p>Aqui está um exemplo que bloqueia o loop principal:<\/p>\n<pre><code><span class=\"token function\">setTimeout<\/span><span class=\"token punctuation\">(<\/span>\n  <span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> console<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'Oi a fila de retorno'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">,<\/span>\n  <span class=\"token number\">5000<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span> <span class=\"token comment\">// Mantenha o loop ativo por x tempo<\/span>\n\n<span class=\"token keyword\">const<\/span> stopTime <span class=\"token operator\">=<\/span> Date<span class=\"token punctuation\">.<\/span><span class=\"token function\">now<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">+<\/span> <span class=\"token number\">2000<\/span><span class=\"token punctuation\">;<\/span>\n<span class=\"token keyword\">while<\/span> <span class=\"token punctuation\">(<\/span>Date<span class=\"token punctuation\">.<\/span><span class=\"token function\">now<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">&lt;<\/span> stopTime<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span><span class=\"token punctuation\">}<\/span> <span class=\"token comment\">// Bloqueie o loop principal<\/span>\n<\/code><\/pre>\n<p>Se você executar este código, observe que o loop fica bloqueado por dois segundos. Mas o loop permanece ativo até que o retorno de chamada seja executado em cinco segundos. Depois que o loop principal é desbloqueado, o mecanismo de pesquisa descobre quanto tempo ele espera nos retornos de chamada. Esse loop termina quando a pilha de chamadas é desfeita e não há mais retornos de chamada restantes.<\/p>\n<h2>A fila de retorno de chamada<\/h2>\n<p>Agora, o que acontece quando eu bloqueio o loop principal e agendo um retorno de chamada? Uma vez que o loop é bloqueado, ele não coloca mais callbacks na fila:<\/p>\n<pre><code><span class=\"token keyword\">const<\/span> stopTime <span class=\"token operator\">=<\/span> Date<span class=\"token punctuation\">.<\/span><span class=\"token function\">now<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">+<\/span> <span class=\"token number\">2000<\/span><span class=\"token punctuation\">;<\/span>\n<span class=\"token keyword\">while<\/span> <span class=\"token punctuation\">(<\/span>Date<span class=\"token punctuation\">.<\/span><span class=\"token function\">now<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">&lt;<\/span> stopTime<span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span><span class=\"token punctuation\">}<\/span> <span class=\"token comment\">// Bloqueie o loop principal<\/span>\n\n<span class=\"token comment\">// Isso leva 7 segundos para ser executado<\/span>\n<span class=\"token function\">setTimeout<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> console<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'Executou callback A'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">5000<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<\/code><\/pre>\n<p>Desta vez, o loop permanece ativo por sete segundos. O event loop é burro em sua simplicidade. Ele não tem como saber o que pode ser colocado na fila no futuro. Em um sistema real, os retornos de chamada de entrada são enfileirados e executados, pois o loop principal está livre para pesquisar. O event loop passa por várias fases <em>sequencialmente<\/em> quando é desbloqueado. Portanto, para vencer aquela entrevista de emprego sobre o loop, evite jargões sofisticados como “emissor de evento” ou “padrão de reator”. É um humilde loop de thread único, simultâneo e não bloqueador, não precisa querer complica, lembre-se o simples é poderoso.<\/p>\n<h2>O Event Loop assíncrono / espera<\/h2>\n<p>Para evitar o bloqueio do loop principal, uma ideia é envolver a E / S síncrona em torno do recurso async / await. Caso esteja procurando um bom curso / treinamento de NodeJS te <a href=\"/programador-fullstack-8-semanas\">recomendo esse aqui<\/a>.<\/p>\n<pre><code><span class=\"token keyword\">const<\/span> fs <span class=\"token operator\">=<\/span> <span class=\"token function\">require<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'fs'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<span class=\"token keyword\">const<\/span> <span class=\"token function-variable function\">readFileSync<\/span> <span class=\"token operator\">=<\/span> <span class=\"token keyword\">async<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token parameter\">path<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> <span class=\"token keyword\">await<\/span> fs<span class=\"token punctuation\">.<\/span><span class=\"token function\">readFileSync<\/span><span class=\"token punctuation\">(<\/span>path<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n\n<span class=\"token function\">readFileSync<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'readme.md'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">.<\/span><span class=\"token function\">then<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token parameter\">data<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> console<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span>data<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\nconsole<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'O event loop continua sem bloqueio...'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<\/code><\/pre>\n<p>Tudo o que vier depois de <strong>await<\/strong> vem da fila de retorno de chamada. O código é lido como um código de bloqueio síncrono, mas não bloqueia. Note que async / <a href=\"https://youtu.be/IR9azXeWs2s\" target=\"_blank\" rel=\"noopener\">readFileSync<\/a> await o torna possível, o que o tira do loop principal. Pense em tudo o que vem depois await como não-bloqueador por meio de um retorno de chamada.<\/p>\n<p>O código acima é apenas para fins de demonstração. Em código real, eu recomendo <a href=\"https://youtu.be/IR9azXeWs2s\" target=\"_blank\" rel=\"noopener\">fs.readFile<\/a>, que dispara um retorno de chamada que pode envolver uma <a href=\"https://youtu.be/fRa33RSJpSo\" target=\"_blank\" rel=\"noopener\">promise<\/a>. A intenção geral ainda é válida, porque isso tira o bloqueio de E / S do loop principal.<\/p>\n<h2>Mais detalhes sobre<\/h2>\n<p>E se eu dissesse que o <strong>event loop<\/strong> tem mais do que uma pilha de chamada e mais uma fila de retorno de chamada? E se o <strong>event loop<\/strong> não fosse apenas um loop, mas muitos?<\/p>\n<p>Agora, quero levá-lo para trás da fachada e para visualiza com mais detalhes os componentes internos do <a href=\"/conhecendo-nodejs/\">NodeJS<\/a><\/p>\n<h2>Fases do Event Loop<\/h2>\n<p>Estas são as fases do <strong>Event Loop<\/strong>:<\/p>\n<p><img src=\"/uploads/2020/09/event-loop.png\" alt=\"event loop\n\"><\/p>\n<p>Estrutura event loop<\/p>\n<p>1 . Ás datas / hora são atualizadas. O <strong>Event loop<\/strong> armazena em cache a hora atual no início do loop para evitar chamadas de sistema frequentes relacionadas ao tempo. Essas chamadas de sistema são internas à <strong>libuv<\/strong>.<\/p>\n<p>2 . O loop está vivo? Se o loop tiver identificadores ativos, solicitações ativas ou identificadores de fechamento, ele está vivo. Conforme mostrado, retornos de chamada pendentes na fila mantêm o loop ativo.<\/p>\n<p>3 . Os cronômetros de vencimento são executados. Este é o lugar onde o <strong>setTimeout<\/strong>() ou <strong>setInterval<\/strong>() retornos de chamada executada. O loop verifica o cache se tem <strong>callbacks<\/strong> ativos que expiraram em execução.<\/p>\n<p>4 . Retornos de chamada pendentes na fila são executados. Se a iteração anterior adiou quaisquer retornos de chamada, eles serão executados neste ponto. O <strong>polling<\/strong> normalmente executa <strong>callbacks<\/strong> de E / S imediatamente, mas há exceções. Esta etapa lida com quaisquer retardatários da iteração anterior.<\/p>\n<p>5 . Manipuladores ociosos são executados - principalmente a partir de nomenclatura inadequada, porque eles são executados a cada iteração e são internos ao libuv.<\/p>\n<p>6 . Prepare identificadores para <strong>setImmediate()<\/strong> execução de retorno de chamada na iteração do loop. Esses identificadores são executados antes dos blocos do loop para E / S e preparam a fila para esse tipo de retorno de chamada.<\/p>\n<p>7 . Calcule o tempo limite da votação. O loop deve saber quanto tempo ele bloqueia para E / S. É assim que ele calcula o tempo limite:<\/p>\n<ul>\n<li>Se o loop estiver prestes a sair, o tempo limite é 0;<\/li>\n<li>Se não houver identificadores ou solicitações ativas, o tempo limite será 0;<\/li>\n<li>Se houver algum identificador inativo, o tempo limite é 0;<\/li>\n<li>Se houver algum identificador pendente na fila, o tempo limite será 0;<\/li>\n<li>Se houver alguma fechamento, o tempo limite é 0;<\/li>\n<li>Se nenhuma das opções acima, o tempo limite é definido para o temporizador mais próximo ou, se não houver temporizadores ativos, infinito.<\/li>\n<\/ul>\n<p>8 . O loop bloqueia para E / S com a duração da fase anterior. Os retornos de chamada relacionados a E / S na fila são executados neste ponto.<\/p>\n<p>9 . Verifique a execução de callbacks do identificador. Esta fase é onde <strong>setImmediate()<\/strong> funciona e é a contrapartida para preparar. Quaisquer <strong>setImmediate()<\/strong> retornos de chamada enfileirados no meio da execução de retorno de chamada de E / S são executados aqui.<\/p>\n<p>10 . Fechar callbacks são executados. Esses são identificadores ativos descartados de conexões fechadas.<\/p>\n<p>11 . A iteração termina.<\/p>\n<p>Você deve estar se perguntando por que a pesquisa bloqueia E / S quando deveria ser sem bloqueio? O loop bloqueia apenas quando não há retornos de chamada pendentes na fila e a pilha de chamadas está vazia. No Node, o temporizador mais próximo pode ser definido por <strong>setTimeout<\/strong>, por exemplo. Se definido como infinito, o loop espera nas conexões de entrada com mais trabalho. É um loop semi-infinito, porque a pesquisa mantém o loop ativo quando não há mais nada a fazer e há uma conexão ativa.<\/p>\n<p>Aqui está a versão Unix deste cálculo de tempo limite é toda a sua glória C:<\/p>\n<pre><code>int <span class=\"token function\">uv_backend_timeout<\/span><span class=\"token punctuation\">(<\/span><span class=\"token parameter\"><span class=\"token keyword\">const<\/span> uv_loop_t<span class=\"token operator\">*<\/span> loop<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\n  <span class=\"token keyword\">if<\/span> <span class=\"token punctuation\">(<\/span>loop<span class=\"token operator\">-<\/span><span class=\"token operator\">><\/span>stop_flag <span class=\"token operator\">!=<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">)<\/span>\n    <span class=\"token keyword\">return<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">;<\/span>\n\n  <span class=\"token keyword\">if<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token operator\">!<\/span><span class=\"token function\">uv__has_active_handles<\/span><span class=\"token punctuation\">(<\/span>loop<span class=\"token punctuation\">)<\/span> <span class=\"token operator\">&amp;&amp;<\/span> <span class=\"token operator\">!<\/span><span class=\"token function\">uv__has_active_reqs<\/span><span class=\"token punctuation\">(<\/span>loop<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span>\n    <span class=\"token keyword\">return<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">;<\/span>\n\n  <span class=\"token keyword\">if<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token operator\">!<\/span><span class=\"token constant\">QUEUE_EMPTY<\/span><span class=\"token punctuation\">(<\/span><span class=\"token operator\">&amp;<\/span>loop<span class=\"token operator\">-<\/span><span class=\"token operator\">><\/span>idle_handles<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span>\n    <span class=\"token keyword\">return<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">;<\/span>\n\n  <span class=\"token keyword\">if<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token operator\">!<\/span><span class=\"token constant\">QUEUE_EMPTY<\/span><span class=\"token punctuation\">(<\/span><span class=\"token operator\">&amp;<\/span>loop<span class=\"token operator\">-<\/span><span class=\"token operator\">><\/span>pending_queue<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span>\n    <span class=\"token keyword\">return<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">;<\/span>\n\n  <span class=\"token keyword\">if<\/span> <span class=\"token punctuation\">(<\/span>loop<span class=\"token operator\">-<\/span><span class=\"token operator\">><\/span>closing_handles<span class=\"token punctuation\">)<\/span>\n    <span class=\"token keyword\">return<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">;<\/span>\n\n  <span class=\"token keyword\">return<\/span> <span class=\"token function\">uv__next_timeout<\/span><span class=\"token punctuation\">(<\/span>loop<span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<span class=\"token punctuation\">}<\/span>\n<\/code><\/pre>\n<p>Você pode não estar muito familiarizado com C, mas parece inglês e faz exatamente o que está na fase sete.<\/p>\n<h2>Uma demonstração fase a fase<\/h2>\n<p>Para mostrar cada fase em JavaScript simples:<\/p>\n<pre><code><span class=\"token comment\">// 1. Loop começa, o timestamps é atualizados<\/span>\n<span class=\"token keyword\">const<\/span> http <span class=\"token operator\">=<\/span> <span class=\"token function\">require<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'http'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n\n<span class=\"token comment\">// 2. O loop permanece vivo se houver código na pilha de chamadas para desenrolar<\/span>\n<span class=\"token comment\">// 8. Pesquisar E / S e executar este retorno de chamada de conexões de entrada<\/span>\n<span class=\"token keyword\">const<\/span> server <span class=\"token operator\">=<\/span> http<span class=\"token punctuation\">.<\/span><span class=\"token function\">createServer<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token parameter\">req<span class=\"token punctuation\">,<\/span> res<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> <span class=\"token punctuation\">{<\/span>\n  <span class=\"token comment\">// O retorno de chamada de E / S da rede é executado imediatamente após a pesquisa<\/span>\n  res<span class=\"token punctuation\">.<\/span><span class=\"token function\">end<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n\n<span class=\"token comment\">// Mantenha o loop ativo se houver uma conexão aberta<\/span>\n<span class=\"token comment\">// 7. Se não houver mais nada a fazer, calcule o tempo limite<\/span>\nserver<span class=\"token punctuation\">.<\/span><span class=\"token function\">listen<\/span><span class=\"token punctuation\">(<\/span><span class=\"token number\">3000<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n\n<span class=\"token keyword\">const<\/span> options <span class=\"token operator\">=<\/span> <span class=\"token punctuation\">{<\/span>\n  <span class=\"token comment\">// Evite uma consulta DNS para ficar fora do pool de threads<\/span>\n  <span class=\"token literal-property property\">hostname<\/span><span class=\"token operator\">:<\/span> <span class=\"token string\">'192.0.2.1'<\/span><span class=\"token punctuation\">,<\/span>\n  <span class=\"token literal-property property\">port<\/span><span class=\"token operator\">:<\/span> <span class=\"token number\">3000<\/span>\n<span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">;<\/span>\n\n<span class=\"token keyword\">const<\/span> <span class=\"token function-variable function\">sendHttpRequest<\/span> <span class=\"token operator\">=<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> <span class=\"token punctuation\">{<\/span>\n  <span class=\"token comment\">// Callbacks de E / S de rede executados na fase 8<\/span>\n  <span class=\"token comment\">// Callbacks de E / S de arquivo executados na fase 4<\/span>\n  <span class=\"token keyword\">const<\/span> req <span class=\"token operator\">=<\/span> http<span class=\"token punctuation\">.<\/span><span class=\"token function\">request<\/span><span class=\"token punctuation\">(<\/span>options<span class=\"token punctuation\">,<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> <span class=\"token punctuation\">{<\/span>\n    console<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'Resposta recebida do servidor'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n\n    <span class=\"token comment\">// 9. Executar verificação de retorno de chamada<\/span>\n    <span class=\"token function\">setImmediate<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span>\n      <span class=\"token comment\">// 10. Feche a execução da callback<\/span>\n       server<span class=\"token punctuation\">.<\/span><span class=\"token function\">close<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span>\n        <span class=\"token comment\">// O fim. ALERTA DE SPOILER! O Loop morre no final.<\/span>\n        console<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'Fechando servidor'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n  <span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n  req<span class=\"token punctuation\">.<\/span><span class=\"token function\">end<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">;<\/span>\n\n<span class=\"token comment\">// 3. O cronômetro é executado em 8 segundos, enquanto o loop permanece ativo<\/span>\n<span class=\"token comment\">// O tempo limite calculado antes da votação o mantém ativo<\/span>\n<span class=\"token function\">setTimeout<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> <span class=\"token function\">sendHttpRequest<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">8000<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n\n<span class=\"token comment\">// 11. Fim da iteração..<\/span>\n<\/code><\/pre>\n<p>Como os callbacks de E / S de arquivo são executados na fase quatro e antes da fase nove, espere <strong>setImmediate()<\/strong> disparar primeiro:<\/p>\n<pre><code>fs<span class=\"token punctuation\">.<\/span><span class=\"token function\">readFile<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'leiame.md'<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> <span class=\"token punctuation\">{<\/span>\n  <span class=\"token function\">setTimeout<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> console<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'Arquivo I/O callback via setTimeout()'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token number\">0<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n  <span class=\"token comment\">// Este retorno de chamada é executado primeiro<\/span>\n  <span class=\"token function\">setImmediate<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> console<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'Arquivo I/O callback via setImmediate()'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<span class=\"token punctuation\">}<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<\/code><\/pre>\n<p>A E / S de rede sem uma pesquisa de DNS é menos cara do que a E / S de arquivo, porque é executada no <strong>event loop<\/strong> principal. Em vez disso, a E / S do arquivo é enfileirada por meio do pool de threads. Uma pesquisa de DNS também usa o pool de threads, então isso torna a E / S de rede tão cara quanto a E / S de arquivo.<\/p>\n<h2>Pool de Thread - Event loop<\/h2>\n<p>Os componentes internos do nó têm duas partes principais: o mecanismo JavaScript V8 e o libuv. E / S de arquivo, pesquisa de DNS e E / S de rede acontecem via libuv.<\/p>\n<p>Esta é a arquitetura geral:<\/p>\n<p><img src=\"/uploads/2020/09/libuv.png\" alt=\"\"><\/p>\n<p>Fonte da imagem: documentação do <a href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"noopener\">libuv<\/a><\/p>\n<p>Para E / S de rede, o <strong>event loop<\/strong> pesquisa dentro do encadeamento principal. A thread não é segura para threads porque não muda de contexto com outro thread. A E / S de arquivo e a pesquisa de DNS são específicas da plataforma, portanto, a abordagem é executá-los em um pool de threads. Uma ideia é fazer a pesquisa de DNS você mesmo para ficar fora do pool de threads, conforme mostrado no código acima. Colocar um endereço IP versus localhost, por exemplo, tira a pesquisa do pool. O pool de threads tem um número limitado de threads disponíveis, que pode ser definido por UV_THREADPOOL_SIZEmeio da variável de ambiente. O tamanho do pool de threads padrão é cerca de quatro.<\/p>\n<p>O V8 é executado em um loop separado, esvazia a pilha de chamadas e devolve o controle ao event loop. O V8 pode usar vários encadeamentos para coleta de lixo fora de seu próprio loop. Pense no V8 como o mecanismo que recebe JavaScript bruto e o executa no hardware.<\/p>\n<p>Para o programador médio, o JavaScript permanece com thread único porque não há segurança de thread. V8 e libuv internos giram seus próprios threads separados para atender às suas próprias necessidades.<\/p>\n<p>Se houver problemas de taxa de transferência no Node, comece com o event loop principal. Verifique quanto tempo leva para a aplicação concluir uma única iteração. Não deve durar mais do que cem milissegundos. Em seguida, verifique se há inanição do pool de encadeamentos e o que pode ser despejado do pool. Também é possível aumentar o tamanho do pool por meio da variável de ambiente. A última etapa é fazer um microbenchmark do código JavaScript no V8 que é executado de forma síncrona.<\/p>\n<h2>Empacotando<\/h2>\n<p>O event loop continua a iterar em cada fase à medida que os retornos de chamada são enfileirados. Mas, dentro de cada fase, há uma maneira de enfileirar outro tipo de retorno de chamada.<\/p>\n<p><strong>process.nextTick()<\/strong> vs <strong>setImmediate()<\/strong><\/p>\n<p>No final de cada fase, o loop executa o <strong>process.nextTick()<\/strong> retorno de chamada. Observe que esse tipo de retorno de chamada não faz parte do event loop porque é executado no final de cada fase. O <a href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"noopener\">setImmediate()<\/a> retorno de chamada faz parte do loop geral de eventos, portanto, não é tão imediato quanto o nome indica. Como <strong>process.nextTick()<\/strong> precisa de conhecimento avançado de event loop <a href=\"/programador-fullstack-8-semanas\">clique aqui caso queira ir para o próximo nível em nodejs<\/a>, recomendo o uso <strong>setImmediate()<\/strong> em geral.<\/p>\n<p>Existem alguns motivos pelos quais você pode precisar <strong>process.nextTick():<\/strong><\/p>\n<ul>\n<li>Permita que a E / S da rede lide com erros, limpe ou tente a solicitação novamente antes que o loop continue;<\/li>\n<li>Pode ser necessário executar um retorno de chamada após o desenrolar da pilha de chamadas, mas antes que o loop continue.<\/li>\n<\/ul>\n<p>Digamos, por exemplo, que um emissor de evento deseja disparar um evento enquanto ainda está em seu próprio construtor. A pilha de chamadas deve ser desenrolada antes de chamar o evento.<\/p>\n<pre><code><span class=\"token keyword\">const<\/span> EventEmitter <span class=\"token operator\">=<\/span> <span class=\"token function\">require<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'eventos'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n\n<span class=\"token keyword\">class<\/span> <span class=\"token class-name\">ImpatientEmitter<\/span> <span class=\"token keyword\">extends<\/span> <span class=\"token class-name\">EventEmitter<\/span> <span class=\"token punctuation\">{<\/span>\n  <span class=\"token function\">constructor<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token punctuation\">{<\/span>\n    <span class=\"token keyword\">super<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n\n    <span class=\"token comment\">// Acione isso no final da fase com uma pilha de chamadas desfeita<\/span>\n    process<span class=\"token punctuation\">.<\/span><span class=\"token function\">nextTick<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> <span class=\"token keyword\">this<\/span><span class=\"token punctuation\">.<\/span><span class=\"token function\">emit<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'eventos'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n  <span class=\"token punctuation\">}<\/span>\n<span class=\"token punctuation\">}<\/span>\n\n<span class=\"token keyword\">const<\/span> emitter <span class=\"token operator\">=<\/span> <span class=\"token keyword\">new<\/span> <span class=\"token class-name\">ImpatientEmitter<\/span><span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\nemitter<span class=\"token punctuation\">.<\/span><span class=\"token function\">on<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'event'<\/span><span class=\"token punctuation\">,<\/span> <span class=\"token punctuation\">(<\/span><span class=\"token punctuation\">)<\/span> <span class=\"token operator\">=><\/span> console<span class=\"token punctuation\">.<\/span><span class=\"token function\">log<\/span><span class=\"token punctuation\">(<\/span><span class=\"token string\">'Ocorreu um evento impaciente!'<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">)<\/span><span class=\"token punctuation\">;<\/span>\n<\/code><\/pre>\n<p>Permitir que a pilha de chamadas seja desenrolada pode evitar erros como RangeError: Maximum call stack size exceeded. Uma pegadinha é ter certeza de process.nextTick()que não bloqueia o event loop O bloqueio pode ser problemático com chamadas de retorno de chamada recursivas na mesma fase.<\/p>\n<h2>Conclusão<\/h2>\n<p>O event loop é a simplicidade em sua sofisticação final. É preciso um problema difícil, como assincronia, segurança de thread e simultaneidade. Ele remove o que não ajuda ou o que não precisa e maximiza o rendimento da maneira mais eficaz possível. Por causa disso, os programadores de Node gastam menos tempo com bugs assíncronos e mais tempo entregando novos recursos.<\/p>\n<h2>Recomendado<\/h2>\n","date":"2020-09-09T00:00:00.000Z","readingTime":17,"title":"Event Loop NodeJS: Um Guia Completo Para Iniciante","categories":["nodejs"],"tags":["event-loop","javascript","nodejs"],"description":"A assincronia em qualquer linguagem de programação é difícil e o event loop vem pra resolver isso. Conceitos como simultaneidade, paralelismo e deadlocks fazem tremer até os engenheiros mais experientes. O código executado de forma assíncrona é imprevisível e difícil de rastrear quando há bugs. O problema é inevitável porque a computação moderna possui vários núcleos. Há um limite térmico em cada núcleo da CPU, e nada está ficando mais rápido. Isso pressiona o desenvolvedor a escrever um código eficiente que aproveite as vantagens do hardware.","imgArticle":"/thumbnail-article/event-loop-nodejs.png","imgHome":"/thumbnail-home/event-loop-nodejs.png"},"n-0-0-10-0-0":{"expanded":false},"n-0-0-10-0-0-0-0-0-0-1-0":{}};
      window.environment = {"client":false,"server":true,"development":false,"production":true,"mode":"ssg","key":"b6f69c3da1fe0952166c8eac4ca0361473a2362c"};
      window.settings = {};
      window.worker = {"enabled":true,"fetching":false,"preload":[],"headers":{},"api":"","cdn":"","protocol":"https","queues":{},"online":true,"responsive":true};
      window.params = {"slug":"event-loop-em-node-guia-completo"};
      window.project = {"domain":"tipscode.com.br","name":"TipsCode","color":"#D22365","type":"website","display":"standalone","orientation":"portrait","scope":"/","root":"/","sitemap":true,"favicon":"/favicon-96x96.png","disallow":[],"icons":{"72":"/icon-72x72.png","96":"/icon-96x96.png","128":"/icon-128x128.png","144":"/icon-144x144.png","152":"/icon-152x152.png","180":"/icon-180x180.png","192":"/icon-192x192.png","384":"/icon-384x384.png","512":"/icon-512x512.png"}};
      window.context = {};
      document.addEventListener('DOMContentLoaded', () => {
        const script = window.document.createElement('script');
        script.src = '/nullstack/b6f69c3da1fe0952166c8eac4ca0361473a2362c/client.js';
        script.integrity = '';
        script.crossOrigin = 'anonymous';
        document.body.append(script);
      });
    </script>
  </body>
</html>